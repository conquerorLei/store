### 1 密码修改

#### 1.1  持久层

##### 1.1.1  规划需要执行的SQL语句

根据用户的uid修改用password值。

```sql
update user set password = ?, modified_user = ?, modified_time = ? where uid = ?;
```

根据uid查询用户的数据。在修改密码之前，首先要保证当前这用户的数据存在，检测是否被标记为已经删除、检测输入的原始密码是否正确。

```sql
select * from t_user where uid = ?;
```

##### 1.1.2 设计接口和抽象方法

在UserMapper接口中添加方法

```java
	/**
     * @author LiXianLei
     * @describtion 修改密码
     * @return {@link Integer} 影响的行数
     * @param uid 用户编号
     * @param password 修改后的密码
     * @param modifiedUser 修改人
     * @param modifiedTime 修改时间
     * @time 2022/1/13 21:07
     **/
    Integer updatePassword(Integer uid, String password, String modifiedUser, Date modifiedTime);

    /**
     * @author LiXianLei
     * @describtion 根据用户id查询用户
     * @return {@link User} 用户
     * @param uid 用户编号
     * @time 2022/1/13 21:08
     **/
    User findByUid(Integer uid);
```

##### 1.1.3 编写映射

在UserMapper.xml文件中实现这个方法

```xml
<update id="updatePassword">
    update t_user
    set password = #{password},
    modified_user = #{modifiedUser},
    modified_time = #{modifiedTime}
    where uid = #{uid}
</update>
<select id="findByUid" resultMap="UserEntityMap">
    select * from t_user where uid = #{uid}
</select>
```

##### 1.1.4 测试接口是否可用

```java
@Test
public void updatePassword(){
    String password = "123456";
    Date date = new Date();
    Integer rows = userMapper.updatePasswordByUid(1, password, "管理员", date);
    if(rows == 1) System.out.println("密码已经修改");
    else System.out.println("发生未知错误");
}
@Test
public void findByUid(){
    User user = userMapper.findByUid(1);
    System.out.println(user);
}
```

![密码测试持久层提交记录](https://gitee.com/QingShanxl/pictures/raw/master/img//image-20220113205631830.png)

#### 1.2 业务层

##### 1.2.1 规划异常

1. 用户不存在，或者已经被删除
2. 用户原密码不正确
3. 另外就是执行数据库更新操作的时候可能会出现异常：UpdateException

##### 1.2.2 设计接口和实现抽象方法

```java
	/**
     * @author LiXianLei
     * @describtion 更新用户密码
     * @return 没有返回值
     * @param uid 用户编号
     * @param username 用户名称
     * @param oldPassword 原密码
     * @param newPassword 新密码
     * @time 2022/1/14 11:21
     **/
    void changePassword(Integer uid, String username, String oldPassword, String newPassword);
```

1.2.3 测试

#### 1.3 控制层

##### 1.3.1 处理异常

处理新增异常UpdateException

##### 1.3.2 设计请求

```
/users/change_password
POST
String oldPassword,String newPassword, HttpSession session
JsonResult<Void>
```

##### 1.3.3 实现请求

```java
@RequestMapping("change_password")
public JsonResult<Void> changePassword(String oldPassword, String newPassword, HttpSession session){
    Integer uid = getUidFromSession(session);
    String username = getUsernameFromSession(session);
    userService.changePassword(uid, username, oldPassword, newPassword);
    return new JsonResult<>(OK, "修改成功");
}
```

测试

![测试接口](https://gitee.com/QingShanxl/pictures/raw/master/img/gpLZuo561jkmhdG.png)

#### 1.4 前端页面

直接添加ajax请求就好

```javascript
$("#btn-change-password").click(function(){
    $.ajax({
        url: "/users/change_password",
        type: "POST",
        data: $("#form-change-password").serialize(),
        dataType: "JSON",
        success: function(json){
            if(json.state == 200){
                alert("修改成功，请使用新密码登录");
                location.href="login.html";
            }else{
                alert(json.message);
            }
        },
        error: function(xhr){
            alert("修改密码产生未知错误" + xhr.status);
        }
    });
});
```

### 2 个人资料修改

#### 2.1 持久层

##### 2.1.1 规划需要执行的SQL语句

1. 根据已经登录的用户ID查询当前用户是否存在(已经存在)

   ```sql
   select * from t_user where uid = ?
   ```

2. 对数据库中的对应字段进行更新操作

   ```sql
   update t_user
   set phone = ?,
   	email = ?,
   	gender = ?,
   	modified_user = ?,
   	modified_time = ?
   where uid = ?
   ```

##### 2.1.2 设计接口

在UserMapper中编写上述需要执行的SQL语句对应的接口

```java
	/**
     * @author LiXianLei
     * @describtion 对t_user表中的phone,email,gender以及隐藏字段modified_user,modified_time进行修改
     * @return {@link Integer} 返回影响的行数
     * @param uid 用户id
     * @param phone 用户手机号码
     * @param email 用户邮箱
     * @param gender 用户性别
     * @param modifiedUser 修改人
     * @param modifiedTime 修改时间
     * @time 2022/1/14 15:29
     **/
    Integer updateInfoByUid(Integer uid, 
                            String phone, 
                            String email, 
                            Integer gender, 
                            String modifiedUser,
                            String modifiedTime);
```



##### 2.1.3 编写映射

在UserMapper.xml文件中添加上述添加的接口对应的以映射

```xml
<update id="updateInfoByUid">
    update t_user
    set phone = #{phone},
        email = #{email},
        gender = #{gender},
        modified_user = #{modifiedUser},
        modified_time = #{modifiedTime}
    where uid = #{uid}
</update>
```

优化：处于安全性考虑，我们更倾向于在phone等显式字段设置值的时候，我们不倾向于设置null，所以我们可以在MyBatis中设置`<if>`标签限制

```xml
<update id="updateInfoByUid">
        update t_user
        set
        <if test="phone != null">phone = #{phone},</if>
        <if test="email != null">email = #{email},</if>
        <if test="gender != null">gender = #{gender},</if> 
            modified_user = #{modifiedUser},
            modified_time = #{modifiedTime}
        where uid = #{uid}
    </update>
```

> 对于隐藏数据，modifiedUser和modifiedTime这两者一定不为null。首先对于modifiedUser，直接保存在session中，如果用户没有登录，那么就无法跳转到资料修改的界面，用户一旦登录，那么modifiedUser一定存在于session中。另外，对于modifiedTime而言，是直接在后端进行声明的，所以也无需考虑是否为null

##### 2.1.4 优化

对于我们的接口设计，我们可以发现，全部的字段都是User对象中的字段，所以我们可以考虑直接传入User对象。这样依据SpringBoot的依赖注入就可以简写形参列表

```java
/**
 * @author LiXianLei
 * @describtion 修改用户数据
 * @return {@link Integer} 影响的行数
 * @param user 需要进行修改的用户数据进行封装
 * @time 2022/1/14 16:23
 **/
Integer updateInfoByUid(User user);
```



##### 2.1.5 测试

在test文件夹下对应的mapper测试路径的UserMapperTests文件中测试updateInfoByUid方法

```java
@Test
public void updateInfoByUid(){
    User user = userMapper.findByUid(6);
    user.setModifiedUser("测试用户1");
    user.setModifiedTime(new Date());
    int rows = userMapper.updateInfoByUid(user);
    System.out.println(rows);
}
```

![测试updateInfoByUid](https://gitee.com/QingShanxl/pictures/raw/master/img/image-20220114155334517.png)

#### 2.2 业务层

##### 2.2.1 规划异常

1. 页面在渲染的时候需要访问后端数据，获取用户的信息，这时候可能出现用户找不到的异常：UsernameNotFoundException
2. 在更新数据时，可能产生数据库相关的异常：UpdateException

##### 2.2.2 设计接口和实现抽象方法

###### 2.2.2.1 接口设计

1. 返回用户数据的接口

   ```java
   /**
    * @author LiXianLei
    * @describtion 根据用户id返回用户信息
    * @return {@link User} 返回用户
    * @param uid 用户编号
    * @time 2022/1/14 15:59
    **/
   User getByUid(Integer uid);
   ```

2. 修改用户数据的接口

   ```java
   /**
        * @author LiXianLei
        * @describtion 更新数据
        * @return 不需要返回数据
        * @param uid 用户id
        * @param username 用户名(填写修改用户的字段)
        * @param user 包含修改字段的user对象
        * @time 2022/1/14 16:02
        **/
   void changeInfo(Integer uid, String username, User user);
   ```

###### 2.2.2.2 方法实现

```java
@Override
public User getByUid(Integer uid) {
    User res = userMapper.findByUid(uid);
    if(res == null || res.getIsDelete() == 1){
        throw new UsernameNotFoundException("用户数据不存在");
    }
    User user = new User();
    user.setPhone(res.getPhone());
    user.setEmail(res.getEmail());
    user.setGender(res.getGender());
    return user;
}

@Override
public void changeInfo(Integer uid, String username, User user) {
    User res = userMapper.findByUid(uid);
    if(res == null || res.getIsDelete() == 1){
        throw new UsernameNotFoundException("用户数据不存在");
    }
    user.setUid(uid);
    user.setModifiedUser(username);
    user.setModifiedTime(new Date());
    int rows = userMapper.updateInfoByUid(res);
    if(rows != 1){
        throw new UpdateException("更新时产生未知的异常");
    }
}
```

#### 2.3 控制层

##### 2.3.1 处理异常

没有产生新的异常，这一步直接省略

##### 2.3.2 设计接口

1. 页面渲染时需要获得当前用户的部分数据

   ```
   /users/get_info
   POST
   HttpSession session
   JsonResult<User>
   ```

2. 可以修改用户数据

   ```
   /users/change_info
   POST
   HttpSession session, User user
   JsonResult<Void>
   ```

##### 2.3.3 实现接口

```java
@RequestMapping("get_info")
public JsonResult<User> getInfo(HttpSession session){
    Integer uid = getUidFromSession(session);
    User user = userService.getByUid(uid);
    return new JsonResult<>(OK, user);
}

@RequestMapping("change_info")
public JsonResult<Void> changeInfo(HttpSession session, User user){
    Integer uid = getUidFromSession(session);
    String username = getUsernameFromSession(session);
    userService.changeInfo(uid, username, user);
    return new JsonResult<>(OK, "修改成功");
}
```

##### 2.3.4 测试接口

![get_info接口测试](https://gitee.com/QingShanxl/pictures/raw/master/img/image-20220114164956929.png)

![change_info接口测试](https://gitee.com/QingShanxl/pictures/raw/master/img/image-20220114165030035.png)

#### 2.4 前端页面

这里需要注意的是，首先我们在渲染页面的时候，需要首先连接接口get_info并获取数据添加到页面指定位置

其次就是在点击按钮之后访问后端的接口对数据库进行修改

```js
// 页面渲染时对某一部分的数据进行加载
$(document).ready(function(){
    $.ajax({
        url: "/users/get_info",
        type: "POST",
        dataType: "JSON",
        success: function(json){
            console.log(json);
            if(json.state == 200){
                $("#username").val(json.data.username);
                $("#phone").val(json.data.phone);
                $("#email").val(json.data.email);
                let radio = json.data.gender == 0 ? $("#gender-female") : $("#gender-male");
                radio.prop("checked","checked");
            }else{
                alert(json.message);
            }
        },
        error: function(xhr){
            alert("发生未知错误" + xhr.status);
        }
    });
});
// 点击后对数据库进行修改
$("#btn-change-info").click(function(){
    $.ajax({
        url: "/users/change_info",
        type: "POST",
        data: $("#form-change-info").serialize(),
        dateType: "JSON",
        success: function(json){
            if(json.state == 200){
                alert("修改成功");
                location.href = "userdata.html";
            }else{
                alert(json.message);
            }
        },
        error: function(xhr){
            alert("发生未知错误" + xhr.status);
        }
    });
});
```

